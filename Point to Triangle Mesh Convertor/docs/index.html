<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title>Point Cloud to Mesh Project Proposal | CS 184 </title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
    <style>
        body {
            max-width: 1000px;
            margin: auto;
            padding: 20px;
            line-height: 1.4;
            font-family: 'Open Sans', sans-serif;
            color: #121212;
        }

        h1,
        h2,
        h3,
        h4 {
            font-family: 'Source Sans Pro', sans-serif;
        }

        section>h3 {
            border-bottom: 1px dashed gray;
        }

        em {
            font-style: italic;
        }

        .figure {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            flex-wrap: wrap;
        }
    </style>
</head>


<body>
    <h1>Point Cloud to Mesh Project Proposal for CS184 <br>
        <small><em>Angel Ibarra, Sayan Paul, and Junyi Zhu</em></small>
    </h1>

    <div class="accordion" id="project-sections">
        <div class="card">
            <div class="card-header" id="proposal-card-heading">
                <h2 class="mb-0">
                    <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#proposal-content" aria-expanded="false" aria-controls="proposal-content">
                        Project Proposal
                    </button>
                </h2>
            </div>

            <div id="proposal-content" class="collapse" aria-labelledby="proposal-card-heading" data-parent="#project-sections">
                <div class="card-body">
                    <section>
                        <h3>Title, Summary, and Team Members</h3>
                        <p>The title of our project is Point Cloud to Mesh, which transforms point cloud data, i.e a set of 3D points, into a 3D mesh representation by utilizing the <a href="http://mesh.brown.edu/taubin/pdfs/bernardini-etal-tvcg99.pdf">Ball-Pivoting Algorithm (BPA)</a>, which will be the foundation to create triangle meshes. The team members are Junyi Zhu, Sayan Paul, and Angel Ibarra.</p>
                    </section>

                    <section>
                        <h3>Problem Description</h3>
                        <p>When scanning real-world objects, one commonly uses lasers to generate a point cloud corresponding to sample the shape and overall structure of an object. Points clouds are certainly useful to quickly visualize objects; however, when performing tasks like ray tracing or object collision, a triangle mesh has much more structure and is much more useful. The challenge, then, is to generate triangle meshes from these point clouds that closely approximate the original object, and to do so efficiently for high-resolution point clouds. In this project, we will primarily implement and investigate BPA as a time- and memory-efficient method to create quality 3D meshes.</p>
                    </section>

                    <section>
                        <h3>Goals and deliverables</h3>
                        <ul>
                            <li>We will generate images of the constructed meshes for BPA, along with visualizations for how different modifications (e.g. different choices for ball radii) can affect the final result.</li>
                            <li>Our main metric for success is the number of disjoint meshes generated by our implementation for a certain point cloud. This value would be 1 if we successfully create a continuous mesh.</li>
                            <li>Secondary metric is the time it takes to render a mesh given a point cloud. If possible, we will use a standard profiler (e.g. <code>perf</code> from Linux perf-tools or XCode Instruments), but we might use wall clock time if profiling has a significant performance hit.</li>
                            <li>We hope to find out how adaptable BPA is to different point meshes, and whether it needs hand-tuning to properly generate meshes for some difficult cases, as well as whether certain acceleration structures actually have a benefit in the general case.</li>
                        </ul>

                        <h4>What we plan to deliver:</h4>
                        <ul>
                            <li>After implementing BPA we hope to produce a watertight mesh. This implies overcoming the issue of holes that comes from miscalculating the proper radius of our circles</li>
                        </ul>

                        <h4>What we hope to deliver:</h4>
                        <ul>
                            <li>
                                Acceleration structures for BPA:
                                <ul>
                                    <li>Sparse voxel array, which helps when a point cloud is a small part of a volume</li>
                                    <li>KD tree to find nearby points to get a seed triangle</li>
                                </ul>
                            </li>
                            <li>Intelligently selecting different ball sizes when doing multiple passes.</li>
                        </ul>
                    </section>

                    <section>
                        <h3>Schedule</h3>
                        <ul>
                            <li>
                                <b>Week One</b> (4/12 &ndash; 4/18)
                                <ul>
                                    <li>Figure out how to render point cloud files and begin setting up the files for BPA, which includes understanding how to incorporate the mesh.c file from project two or utilizing Mitsuba.</li>
                                </ul>
                            </li>
                            <li>
                                <b>Week Two</b> (4/19 &ndash; 4/25)
                                <ul>
                                    <li>Test BPA and check for any bugs/inconsistencies</li>
                                    <li>Optimize the code by implementing acceleration structures</li>
                                </ul>
                            </li>
                            <li>
                                <b>Week Three</b> (4/26 &ndash; 5/2)
                                <ul>
                                    <li>Run multiple test to find where BPA fails and determine how to modify our implementation to pass these cases</li>
                                </ul>
                            </li>
                            <li>
                                <b>Week Four</b> (5/3 &ndash; 5/9)
                                <ul>
                                    <li>Finish writing our final report and prepare our slides for the presentation</li>
                                </ul>
                            </li>
                        </ul>
                    </section>

                    <section>
                        <h3>Resources</h3>
                        <ul>
                            <li>We will be following the BPA algorithm from the following <a href="http://mesh.brown.edu/taubin/pdfs/bernardini-etal-tvcg99.pdf">article</a>.</li>
                            <li>Additionally, we will extending the <a href="https://github.com/mitsuba-renderer/mitsuba2">Mitsuba 2</a> project which is a research-oriented rendering system that will enable us to render our meshes.</li>
                        </ul>
                    </section>
                </div>
            </div>
        </div>
        <div class="card">
            <div class="card-header" id="milestone-card-heading">
                <h2 class="mb-0">
                    <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#milestone-content" aria-expanded="false" aria-controls="milestone-content">
                        Milestone Update
                    </button>
                </h2>
            </div>
            <div id="milestone-content" class="collapse" aria-labelledby="milestone-card-heading" data-parent="#project-sections">
                <div class="card-body">
                    <section>
                        <h3>Extra Materials</h3>
                        <p><a href="https://docs.google.com/presentation/d/1Erpvlpw9NSmbSUaYofIZEzwOzvtn39mnNhKPGoKX8_c/edit?usp=sharing"><b>Presentation Slides</b></a></p>
                        <p><a href="https://drive.google.com/open?id=1BhUnheb5qrlwW6YdCwED56P1vxiHtlbM"><b>Presentation Video</b></a></p>
                    </section>
                    <section>
                        <h3>Accomplished</h3>
                        <p>Since we have an <a href="http://mesh.brown.edu/taubin/pdfs/bernardini-etal-tvcg99.pdf">article</a> that describes the basis for the Ball-Pivoting algorithm (BPA), we’ve focused on providing all of the supplemental structures to support and implement the algorithm.</p>

                        <p>The first major task was to tackle the issue of parsing a <code>.ply</code> file. We used the <a href="https://github.com/ddiakopoulos/tinyply"><code>tinyply</code></a> package which handles the work of parsing a variety of <code>.ply</code> formats and deserializing them into C++ data structures. We quickly realized that BPA relies on the vertices having normals to verify the correctness of the constructed face normals, which the <code>.ply</code> files from the <a href="https://graphics.stanford.edu/data/3Dscanrep/">Stanford 3D Scanning Repository</a> do not have. However, the files do have the actual triangle mesh information along the normals for each triangle. We ended up using those to compute area-weighted vertex normals for each vertex. However, the triangles in these files were represented simply by a list of vertices without any guarantee about the winding order. As such, we added a check at the end of our code that made sure that each triangle's normal faced the same direction as the computed vertex normals. The <code>.ply</code> files that we've tested on so far have passed this check so we feel confident in moving forward with this technique.</p>

                        <p>The next task was deciding which data structure to use to store our points. A crucial part of the algorithm is being able to quickly find points that lie within a certain radius of a specified point. For simplicity, we chose to use a voxel array for this purpose, making sure the side length for each voxel was the same as the aforementioned radius. Then, finding the nearby points is as simple as returning all of the points in the 27 voxels surrounding the point (including the one that contains it). This was originally meant to be a potential acceleration structure that we were going to explore once we had a na&iuml;ve BPA implementation, however it was relatively easy to implement so we decided to use it in our base implementation.</p>

                        <p>After these two tasks were completed, we focused on fleshing out the BPA by implementing all of the other supporting functions and checks.</p>
                    </section>

                    <section>
                        <h3>Preliminary Results</h3>
                        <p>So far, the <code>.ply</code> parser and voxel array are functioning correctly. We used some basic sanity checks for the <code>.ply</code> parser to verify these results, including the vertex normal verification mentioned above as well as inspecting the original <code>.ply</code> file to see if the vertices and their normals are consistent. We are still implementing the core components of the BPA, so we have not been able to test it out.</p>
                    </section>

                    <section>
                        <h3>Reflection</h3>
                        <p>Originally, the BPA seemed fairly straightforward, however, after further examination it became apparent that it was more complicated than we expected. So, we did further research to get a better grasp of the algorithm and managed to find another <a href="https://www.ipol.im/pub/art/2014/81/">article</a> that better explained the inner workings of BPA, which solidified our understanding. From here we split up different sections of the project within the group and continued to have meetings throughout the week to maintain a consistent workflow. </p>
                    </section>

                    <section>
                        <h3>Work Plan</h3>
                        <p>We are still somewhat on track with our first proposed work schedule, however, by this time we were supposed to have BPA up and running. With that said, we plan to finish implementing BPA by integrating each members' code together, and then proceed with debugging and testing. From here, we’ll gauge whether or not we’ll have enough time to implement acceleration structures to make the mesh generation faster. Our updated schedule is:</p>
                        <ul>
                            <li>
                                <b>Week Three</b> (4/26 &ndash; 5/2)
                                <ul>
                                    <li>Finishing touches on the BPA implementation.</li>
                                    <li>Run multiple tests to find where BPA fails and determine how to modify our implementation to pass these cases</li>
                                </ul>
                            </li>
                            <li>
                                <b>Week Four</b> (5/3 &ndash; 5/9)
                                <ul>
                                    <li>Finish writing our final report and prepare our slides for the presentation</li>
                                    <li>Time permitting, optimize the code by implementing acceleration structures.</li>
                                </ul>
                            </li>
                        </ul>
                    </section>
                </div>
            </div>
        </div>
        <div class="card">
            <div class="card-header" id="final-report-card-heading">
                <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#final-report-content" aria-expanded="true" aria-controls="final-report-content">
                        Final Report
                    </button>
                </h2>
            </div>
            <div id="final-report-content" class="collapse show" aria-labelledby="final-report-card-heading" data-parent="#project-sections">
                <div class="card-body">
                    <section>
                        <h3>Extra Materials</h3>
                        <p><a href="https://docs.google.com/presentation/d/1Erpvlpw9NSmbSUaYofIZEzwOzvtn39mnNhKPGoKX8_c/edit?usp=sharing"><b>Presentation Slides</b></a></p>
                        <p><a href="https://drive.google.com/file/d/1XU0_XGX7rqh9FOaCMjrhQLk_5eDNa2Yx/view"><b>Presentation Video</b></a></p>
                       
                    </section>
                    <section>
                        <h3>Abstract</h3>
                        <p>This project focused on reconstructing a 3D watertight triangle mesh given a set of points (and surface normals at those points) by implementing the Ball Pivoting algorithm (BPA) [1]. BPA&rsquo;s main pitch is that it iteratively adds triangles to an unfinished mesh by pivoting a ball with some predetermined radius around edges on the boundary of the mesh and connecting the first point it hits that isn&rsquo;t already in the mesh. Through careful labelling of the vertices and edges and appropriate layers of indirection, we are able to output these meshes in a time- and memory-efficient manner. With our implementation, we can construct a partial mesh with ~50k triangles in ~1 second.</p>
                    </section>

                    <section>
                        <h3>Technical Approach</h3>
                        <p>One of the first tasks taken into consideration was how to parse a <code>.ply</code> file to get the information of the points. This was trivial since we used the <a href="https://github.com/ddiakopoulos/tinyply"><code>tinyply</code></a> package which handled most of the workload, however, it doesn’t handle the case of calculating the normals of the points if the <code>.ply</code> file didn’t have that information. Therefore, we calculated the normals for each vertex by taking the area-weighted average of the normals of the triangles incident to that vertex. Overall, this decision was essential when it came to setting up the necessary data that BPA would use to generate the meshes.</p>
                        <p>A major aspect of this project dealt with how to group points in a 3D space and use that information to render the meshes. With that said, the paper [2] we mainly based our implementation off uses an octree data structure to group and search through points. This approach can handle an arbitrary number of points and find its neighbors in an optimized manner. However, it proved to be a bit complex for our task of finding and grouping points relative to 3D space. As a result, for the sake of time and simplicity we deviated from this approach and decided to implement a voxel array which groups points into cubes, thus creating a more robust method of finding a point’s neighbors that will come into play once we implement the other aspects of BPA.</p>
                        <p>Besides this major change, which has a significant impact on performance, we followed the general algorithm of BPA since it was difficult to stray away from the original implementation or make it even more efficient than it already is. This encompasses implementing the core methods such as finding a seed triangle, finding a points neighbors, expanding the mesh through appending new triangles, etc.</p>
                        <p>Now, when it comes to the issues encountered throughout the development process they will be discussed in depth in the "Results" section of the report. Here we will highlight bugs and mistakes we made and provide images that depict our progress of overcoming these issues until we reach our final result.</p>
                    </section>

                    <section>
                        <h3>Results</h3>
                        <p>The initial version of our algorithm took very long to execute with even simple meshes and produced strangely shaped triangles. The following images took about 30 minutes to render a fraction of the entire mesh.</p>

                        <div class="figure">
                            <img style="width: 33%;" src="images/image5.png">
                            <img style="width: 33%;" src="images/image1.png">
                        </div>

                        <p>After doing some profiling, we found that the vast majority (&gt;98%) of our time was spent trying to find seed triangles. We noticed that if no triplet of points inside a voxel produced a valid seed triangle, then we didn’t need to consider that same voxel when trying to find a new seed triangle in the future. We added a boolean flag to each voxel that signified whether it had been visited before and skipped these voxels in our <code>find_seed_triangle</code> procedure. We were able to produce the meshes below, composed of a few thousand triangles, in a ~20 minutes with this optimization.</p>

                        <div class="figure">
                            <img style="width: 33%;" src="images/image2.png">
                            <img style="width: 33%;" src="images/image4.png">
                        </div>

                        <p>There was one final change we had to make to produce the image below. Although the mesh that we outputted corresponded directly with the one displayed, we noticed that roughly half of the triangles were missing when viewing the mesh with XCode’s <code>.ply</code> viewer, making a sort of checkerboard pattern with the triangles. This happened because XCode didn’t render triangles where the face normal (derived from the winding order) wasn’t facing the same direction as the three vertex normals. Once fixing the winding order for these triangles, we were able to visualize the following result.</p>

                        <div class="figure">
                            <img style="width: 33%;" src="images/image3.png">
                        </div>
                    </section>

                    <section>
                        <h3>References</h3>
                        <ol>
                            <li>F. Bernardini, J. Mittleman, H. Rushmeier, C. Silva and G. Taubin, "The ball-pivoting algorithm for surface reconstruction," in IEEE Transactions on Visualization and Computer Graphics, vol. 5, no. 4, pp. 349-359, Oct.-Dec. 1999, doi: 10.1109/2945.817351.
                            </li>
                            <li>J. Digne, An Analysis and Implementation of a Parallel Ball Pivoting Algorithm, Image Processing On Line, 4 (2014), pp. 149–168. https://doi.org/10.5201/ipol.2014.81</li>
                        </ol>
                    </section>
                    <section>
                        <h3>Contributions</h3>
                        <h4>Sayan Paul</h4>
                        <ul>
                            <li>Wrote the <code>expand_triangulation</code> function which uses Angel’s and Junyi’s code to expand the mesh.</li>
                            <li>Integrated the <a href="https://github.com/ddiakopoulos/tinyply"><code>tinyply</code></a> library to ingest <code>.ply</code> files from the <a href="https://graphics.stanford.edu/data/3Dscanrep/">Stanford 3D Scanning Repository</a>, parse vertex data, and compute area-weighted normals for these vertex based on the ground-truth triangle mesh in these files.</li>
                            <li>Integrated the various parts of the program so that a single executable ran on a <code>.ply</code> file would output a new <code>.ply</code> file with the mesh information.</li>
                            <li>Constructed the website used for the project reports.</li>
                        </ul>

                        <h4>Angel Ibarra</h4>
                        <ul>
                            <li>Wrote the following functions:</li>
                            <ul>
                                <li><code>get_ball_center</code>: Takes in a triangle and radius value and outputs the center of a ball with that radius that circumscribes that triangle.</li>
                                <li><code>is_empty_ball_config</code>: Checks if a ball with a given center and radius is empty except for the triangle it circumscribes.</li>
                                <li><code>find_seed_triangle</code>: Uses the above two functions to find a set of three points that could be circumscribed by a ball of a specified radius.</li>
                            </ul>
                            <li>Used the <a href="https://github.com/ddiakopoulos/tinyply"><code>tinyply</code></a> library to output the constructed mesh to a <code>.ply</code> file.</li>
                            <li>Made the Milestone Video</li>
                        </ul>

                        <h4>Junyi Zhu</h4>
                        <ul>
                            <li>Wrote the class and function that takes in 3D points and normals and builds the voxelmap structure while converting those points to vertices that contain position, normal, and incident edge information.</li>
                            <li>Wrote the <code>find_candidate</code> function that finds potential vertices to add to a partial mesh.</li>
                            <li>Implement the <code>find_seed_triangle</code> optimization described in the Results section.</li>
                        </ul>
                    </section>
                </div>
            </div>
        </div>
    </div>
</body>

</html>
